# Methods for parsing a PSF file.
from numpy import array, ndarray, reshape
from datetime import datetime
from frc_solve import modprod

# PSF header - skip 2 lines, then read a title
# File -> IO(String)
def read_title(f):
    f.readline() # skip 2
    f.readline()
    n = int(f.readline().split()[0])
    title = ""
    for i in range(n):
        title += f.readline()
    return title

# ck_section(f, "!NATOM") will
# read until parsing a line like, "14 !NATOM",
# and return 14 (or else throw an exception)
# File, String -> IO(Int)
def ck_section(f, name):
    while(True):
        line = f.readline()
        tok = line.split()
        if len(tok) < 2:
            continue
        if tok[1] == name:
            return int(tok[0])
        else:
            raise ValueError, "Expected section %s, found: %s"%(name, line)

# File -> IO([Atom])
def read_atoms(f):
    n = ck_section(f, "!NATOM")
    a = []
    for i in range(n):
        a.append(Atom(f.readline()))
    return a

# File -> IO(Array Int)
def read_bonds(f):
    n = ck_section(f, "!NBOND:")
    # Reshaping will verify the number of bonds actually read.
    return reshape(array(read_ints(f))-1, (n,2))

# Read ints until encountering a blank line
# File -> IO(Array Int)
def read_ints(f):
    l = []
    while(True):
        tok = f.readline().split()
        if len(tok) < 1:
            return l
        l += map(int, tok)

# String -> IO(PSF)
def read_psf(name):
    with open(name, 'r') as f:
        title = read_title(f)
        atoms = read_atoms(f)
        bonds = read_bonds(f)
    return PSF(atoms, bonds)

class PSF:
    def __init__(self, atoms, bonds):
        self.N = len(atoms)
        #self.atoms = atoms
        self.bonds = bonds
        self.q     = array([a['q'] for a in atoms])
        self.m     = array([a['m'] for a in atoms])
        self.resn  = array([a['resn'] for a in atoms])

        self.t     = [a['t'] for a in atoms]
        self.names = [a['name'] for a in atoms]
        self.chain   = [a['chain'] for a in atoms]
        self.res     = [a['res'] for a in atoms]

    def write_atom(self, i):
        return "%8d     %-4s  %5d %4s     %-4s      %4s     %13.6f %9.5f"%(
                    i, self.chain[i], self.resn[i], self.res[i], self.names[i],
                    self.t[i], self.q[i], self.m[i]) \
             + "            0   0.00000     -0.301140E-02"

    def write(self, name):
        d = datetime.utcnow()
        f = open(name, 'w')
        f.write("PSF EXT CMAP CHEQ XPLOR\n\n")
        f.write("         3 !NTITLE\n")
        f.write("* Generated by the Yankee Parameter Server\n")
        f.write("* David M. Rogers (based on ForceSolve, arXiV:1003.4741v1)\n")
        f.write("*  DATE:    %02d/%02d/%02d     %02d:%02d:%02dZ"%(
                d.month, d.day, d.year, d.hour, d.minute, d.second ) \
                + "     CREATED BY USER: davidrogers@usf.edu\n")
        f.write("\n%8d !NATOM\n"%self.N)
        [ f.write(self.write_atom(i)+"\n") for i in range(self.N) ]
        G = [set() for i in range(self.N)]
        for b in self.bonds: # generate node-based connection table
            G[b[0]].add(b[1])
            G[b[1]].add(b[0])
        f.write("\n%8d !NBOND: bonds\n"%len(self.bonds))
        f.write(blocked(self.bonds+1))
        ang = list_angles(G)
        f.write("\n%8d !NTHETA: angles\n"%len(ang))
        f.write(blocked(ang, 9))
        tor = list_dihedrals(self.bonds, G)
        f.write("\n%8d !NPHI: dihedrals\n"%len(tor))
        f.write(blocked(tor))
        imp = list_impropers(G)
        f.write("\n%8d !NIMPHI: dihedrals\n"%len(imp))
        f.write(blocked(imp))
        f.write(vestigal_tail%(blocked([[0]]*self.N), \
                               blocked([[1]]*self.N)))
        f.close()

def list_angles(G):
    angles = []
    for j in range(len(G)):
        angles += [(i+1,j+1,k+1) for i,k in modprod(G[j], G[j]) if i < k]
    return angles

def list_dihedrals(b, G):
    tors = []
    for j,k in b:
        tors += [(i+1,j+1,k+1,l+1) for i,l in modprod(
                                       G[j]-set([k]), \
                                       G[k]-set([j]) ) if i != l]
    return tors

def list_impropers(G):
    return [(i+1,b[0]+1,b[1]+1,b[2]+1) for i,b in enumerate(G) if len(b) == 3]

def concat(x):
    if len(x) == 0:
        return x
    if isinstance(x, ndarray):
        return x.reshape(-1)
    if isinstance(x[0], tuple):
        return sum(x, ())
    return sum(x, [])

def blocked(l, n=8):
    if len(l) == 0:
        return "\n"
    v = concat(l)
    u = (len(v)-n-1) % n + 1
    lines = [("%8d"*n)%tuple(v[i:i+n]) for i in range(0,len(v)-n,n)]
    lines.append( ("%8d"*u)%tuple(v[-u:]) )
    return "\n".join(lines) + "\n" 

vestigal_tail = '''
       0 !NDON: donors


       0 !NACC: acceptors


       0 !NNB

%s
       1       0 !NGRP NST2
       0       1       0

       1 !MOLNT
%s
       0       0 !NUMLP NUMLPH

       0 !NCRTERM: cross-terms
'''

# parse an atom line into a dict
# e.g.
#"14 BUTA     1        BUTA     C4        320  -0.270000       12.0110 0   0.00000     -0.301140E-02"
def Atom(line):
    tok = line.split()
    return { 'n': int(tok[0]),
             'chain': tok[1],
             'resn': int(tok[2]),
             'res': tok[3],
             'name': tok[4],
             't': tok[5],
             'q': float(tok[6]),
             'm': float(tok[7])}

def test():
     from psf import read_psf
     f = read_psf("../glucose.psf")
     f.write("tmp.psf")

