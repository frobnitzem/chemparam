# Methods for creating a molecule topology from a structure.
from babel import PyBabel
from numpy import array, ndarray
from datetime import datetime
from frc_solve import modprod

# assign a name to the atom in the format: %s%d % type, num
def name_atom(t, naming):
    if naming.has_key(t):
        naming[t] += 1
        i = naming[t]
    else:
        naming[t] = 1
        i = 1
    return "%s%d"%(t,i)

# name : String / filename -> IO(Mol)
def read_mol(name):
    mol = PyBabel(name) # returns generator of mols

    naming = {} # special dict to help with naming
    atoms = []
    for i in range(mol.atoms):
        t = mol.t[i] # mmff94 type name
        name = name_atom(mol.elem[i], naming)
        res = mol.res[i]
        #resn = atom.GetResidue().GetNum()
        atoms.append({ 'name': name,
                       'res': res,
                       't': t,
                       'q': mol.q[i],
                       'm': mol.mass[i],
                       'x': mol.x[i]
                    })
    return Mol(atoms, mol.bonds)

# positions are in units of Angstroms
class Mol:
    def __init__(self, atoms, bonds):
        self.N = len(atoms)
        self.bonds = bonds

        self.x     = array([a['x'] for a in atoms])
        self.q     = array([a['q'] for a in atoms])
        self.m     = array([a['m'] for a in atoms])

        self.t     = [a['t'] for a in atoms]
        self.res   = [a['res'] for a in atoms]
        self.names = [a['name'] for a in atoms]
        if len(atoms) > 0 and atoms[0].has_key('chain'):
            self.chain = [a['chain'] for a in atoms]
        else:
            self.chain = ['A' for a in atoms]
        if len(atoms) > 0 and atoms[0].has_key('resn'):
            self.resn = [a['resn'] for a in atoms]
        else:
            self.resn = [1 for a in atoms]

    def write_atom_psf(self, i):
        return "%8d     %-4s  %5d %4s     %-4s      %4s     %13.6f %9.5f"%(
                    i, self.chain[i], self.resn[i], self.res[i], self.names[i],
                    self.t[i], self.q[i], self.m[i]) \
             + "            0   0.00000     -0.301140E-02"

    def write_psf(self, name):
        d = datetime.utcnow()
        f = open(name, 'w')
        f.write("PSF EXT CMAP CHEQ XPLOR\n\n")
        f.write("         3 !NTITLE\n")
        f.write("* Generated by the ChemParameter Server\n")
        f.write("* David M. Rogers (based on ForceSolve, arXiV:1003.4741v1)\n")
        f.write("*  DATE:    %02d/%02d/%02d     %02d:%02d:%02dZ"%(
                d.month, d.day, d.year, d.hour, d.minute, d.second ) \
                + "     CREATED BY USER: davidrogers@usf.edu\n")
        f.write("\n%8d !NATOM\n"%self.N)
        [ f.write(self.write_atom_psf(i)+"\n") for i in range(self.N) ]
        G = [set() for i in range(self.N)]
        for b in self.bonds: # generate node-based connection table
            G[b[0]].add(b[1])
            G[b[1]].add(b[0])
        f.write("\n%8d !NBOND: bonds\n"%len(self.bonds))
        f.write(blocked(array(self.bonds)+1))
        ang = list_angles(G)
        f.write("\n%8d !NTHETA: angles\n"%len(ang))
        f.write(blocked(ang, 9))
        tor = list_dihedrals(self.bonds, G)
        f.write("\n%8d !NPHI: dihedrals\n"%len(tor))
        f.write(blocked(tor))
        imp = list_impropers(G)
        f.write("\n%8d !NIMPHI: dihedrals\n"%len(imp))
        f.write(blocked(imp))
        f.write(vestigal_tail%(blocked([[0]]*self.N), \
                               blocked([[1]]*self.N)))
        f.close()

def list_angles(G):
    angles = []
    for j in range(len(G)):
        angles += [(i+1,j+1,k+1) for i,k in modprod(G[j], G[j]) if i < k]
    return angles

def list_dihedrals(b, G):
    tors = []
    for j,k in b:
        tors += [(i+1,j+1,k+1,l+1) for i,l in modprod(
                                       G[j]-set([k]), \
                                       G[k]-set([j]) ) if i != l]
    return tors

def list_impropers(G):
    return [(i+1,b[0]+1,b[1]+1,b[2]+1) for i,b in enumerate(G) if len(b) == 3]

def concat(x):
    if len(x) == 0:
        return x
    if isinstance(x, ndarray):
        return x.reshape(-1)
    if isinstance(x[0], tuple):
        return sum(x, ())
    return sum(x, [])

def blocked(l, n=8):
    if len(l) == 0:
        return "\n"
    v = concat(l)
    u = (len(v)-n-1) % n + 1
    lines = [("%8d"*n)%tuple(v[i:i+n]) for i in range(0,len(v)-n,n)]
    lines.append( ("%8d"*u)%tuple(v[-u:]) )
    return "\n".join(lines) + "\n" 

vestigal_tail = '''
       0 !NDON: donors


       0 !NACC: acceptors


       0 !NNB

%s
       1       0 !NGRP NST2
       0       1       0

       1 !MOLNT
%s
       0       0 !NUMLP NUMLPH

       0 !NCRTERM: cross-terms
'''

if __name__=="__main__":
    import sys
    mol = read_mol(sys.argv[1])
    print mol.names
    print mol.t
    print mol.q
    print mol.m
    print mol.x.shape
    print len(mol.bonds) + 1 - mol.N

