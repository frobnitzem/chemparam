# Methods for parsing an ITP file.
# Distinct from top, the ITP parser reads information
# associated to a single [ moleculetype ] section
from numpy import array, reshape
from datetime import datetime

__all__ = ["read_itp", "ITP"]

def pred(a):
    return a-1

def succ(a):
    return a+1

def num(l):
    l = map(pred, l)
    if l[0] > l[-1]:
        l.reverse()
    return tuple(l)

def human(l):
    return tuple(map(succ, l))


def read_mol(d, line):
    tok = line.split()
    d['name'] = tok[0]
    d['nrexcl'] = int(tok[1])

# [str] -> IO([Atom])
def read_atom(d, line):
    tok = line.split()
    d[int(tok[0])-1] = Atom(tok)

# [str] -> IO(Array Int)
def read_bond(d, line):
    tok = map(int, line.split())
    d[num(tok[:2])] = tok[2]

def read_angle(d, line):
    tok = map(int, line.split())
    d[num(tok[:3])] = tok[3]

def read_dihedral(d, line):
    tok = map(int, line.split())
    d[num(tok[:4])] = tok[4]

def read_pair(d, line):
    tok = map(int, line.split())
    d[num(tok[:2])] = tok[2]

# String -> IO(ITP)
def read_itp(name):
    parser = { 'moleculetype': read_mol,
               'atoms': read_atom,
               'bonds': read_bond,
               'angles': read_angle,
               'dihedrals': read_dihedral,
               'pairs': read_pair
             }

    out = dict([(k,{}) for k in parser.keys()])
    with open(name, 'r') as f:
        state = 0 # 0: search for moleculetype section
                  # 1: find section
                  # 2: read section
        for line in f.xreadlines():
            line = line.split(';',1)[0] # chop comments
            line = line.strip()
            if not line: continue
            if line[0] != '[':
                if state == 2:
                    parse(section, line)
                continue
            if line[-1] != ']':
                raise ValueError, "Incorrect section format: %s"%line
            # Begin processing a new section
            sec = line[1:-1].strip()
            if state == 0:
                if sec != "moleculetype":
                    continue
            try: # parser, out must include 'moleculetype'
                parse = parser[sec]
                section = out[sec]
                state = 2
            except KeyError:
                state = 1
                continue

    # This line will break if there are missing atom numbers
    # in the range [0, .., natoms-1].
    out['atoms'] = [out['atoms'][i] for i in range(len(out['atoms']))]
    return ITP(**out)

class ITP:
    def __init__(self, moleculetype, atoms, bonds, angles, dihedrals, pairs):
        self.moleculetype = moleculetype
        self.atoms = atoms
        self.bonds = bonds
        self.angles = angles
        self.dihedrals = dihedrals
        self.pairs = pairs

    # Can't work because Mol already imports ITP!
    #def to_mol(self):
    #    return Mol( self.atoms, array( self.bonds.keys() ), \
    #                self.moleculetype['name'] )

    def write_atom(self, at):
        # nr    type   resnr  residu    atom    cgnr        charge          mass
        return "%5d %-4s %5d %-4s %-4s 1 %10.5f %10.5f"%(
                at['n'], at['t'], at['resn'], at['res'], \
                at['name'], at['q'], at['m'] )

    def write(self, name):
        d = datetime.utcnow()
        f = open(name, 'w')
        f.write("; Generated by the ChemParameter Server\n")
        f.write("; David M. Rogers (based on ForceSolve, arXiV:1003.4741v1)\n")
        f.write(";  DATE: %02d/%02d/%02d %02d:%02d:%02dZ\n"%(
                d.month, d.day, d.year, d.hour, d.minute, d.second ))
        f.write(";  CREATED BY USER: predictivestatmech@gmail.com\n")
        f.write("\n[ moleculetype ]; name nrexcl\n")
        f.write("%s %d\n"%(self.moleculetype['name'],
                           self.moleculetype['nrexcl']))
        f.write("\n[ atoms ]\n")
        [ f.write(self.write_atom(at)+"\n") for at in self.atoms ]
        def wfmt(fmt, d):
            f.write("\n".join( fmt % (human(k) + (d[k],))
                               for k in sorted(d.keys())
                             ))
        f.write("\n[ bonds ]\n")
        wfmt("%8d %8d %2d", self.bonds)
        f.write("\n[ angles ]\n")
        wfmt("%8d %8d %8d %2d", self.angles)
        f.write("\n[ dihedrals ]\n")
        d = self.dihedrals
        f.write("\n".join("%8d %8d %8d %8d %2d" % (human(k) + (d[k],))
                          for k in sorted(d.keys()) if d[k] != 2))
        f.write("\n; [ impropers ]\n")
        f.write("\n".join("%8d %8d %8d %8d  2" % human(k)
                          for k in sorted(d.keys()) if d[k] == 2))
        f.write("\n[ pairs ]\n")
        wfmt("%8d %8d %2d", self.pairs)
        f.close()

# parse an atom line into a dict
# e.g.
# "    1 OR       1 LIG  O1   1   -0.56000   15.99491"
def Atom(tok, chain=' '):
    return { 'n': int(tok[0]),
             'chain': chain,
             'resn': int(tok[2]),
             'res': tok[3],
             'name': tok[4],
             't': tok[1],
             'q': float(tok[6]),
             'm': float(tok[7]),
             'x': [0.0, 0.0, 0.0]}

def test():
     from mol import mol_of_itp
     itp = read_itp("../tmp/out/molecule.itp")
     mol_of_itp(itp).write_itp("tmp.itp")

if __name__=="__main__":
    test()
